<!DOCTYPE html>
<html><meta charset="utf-8"><link href="res/doc_style.css" rel="stylesheet" /><body>

<h1 id="easylogger"><img alt="" src="res/icon.png" /> EasyLogger</h1>
<p><strong>EasyLogger</strong> отображает и записывает данные с контроллера с <em>двухканальной</em> версией
прошивки <a href="http://www.obdev.at/products/vusb/easylogger.html">EasyLogger</a>.
Двухканальная версия прошивки разработана <em>Yves Lebrac</em> и опубликована в <a href="http://yveslebrac.blogspot.ru/2008/10/cheapest-dual-trace-scope-in-galaxy.html">его блоге</a>
ещё в 2008 году.
Ещё немного информации можно взять на <a href="http://codeandlife.com/2012/02/22/v-usb-with-attiny45-attiny85-without-a-crystal/">Code and Life</a>.
В прошивке используется библиотека <a href="http://www.obdev.at/products/vusb/index.html"><strong>V-USB</strong></a>.</p>
<p>Файлы:</p>
<pre><code>Файл для запуска программы:         EasyLogger.pyw
Файл настроек:                      config.py
Зависимости:                        Windows, Python 3, PyQt4, PyLab (опция)
</code></pre>
<p>Папки:</p>
<pre><code>img/                папка для сохраняемых изображений
log/                папка записываемых данных (.log)
res/                ресурсы программы (необходимые модули)
__pycache__/        папка кеширования байт-кода питона, создаётся автоматически
</code></pre>
<p>Справка по настройкам в самом файле настроек.</p>
<h1 id="_1">Справка по программе</h1>
<p>Максимальное разрешение — около 1000 сэмплов в секунду.</p>
<h2 id="_2">Мышь и кнопки</h2>
<pre><code>Одинарный щелчок в окне     - перетаскивание окна
Двойной щелчок              - переключение каналов [1,2], [1], [2], [2/1]
Щелчок правой кнопкой       - сохранение картинки в папке img/
Колесо                      - изменение скорости получения данных и обновления окна
                              (изменение происходит по окончании текущего этапа,
                              так что большие задержки приходится пережидать)

Escape                      - сворачивание окна в трей
Space                       - очистка экрана
1                           - первый канал
2                           - второй канал
3                           - каналы 1,2
4                           - каналы 2,1
/                           - режим XY - первый канал - X, второй - Y
*                           - режим XY - первый канал - Y, второй - X
</code></pre>
<h2 id="_3">Файлы</h2>
<p>Имена сохраняемых изображений имеют говорящий сам за себя формат:</p>
<pre><code>ГГГГ-ММ-ЧМ--ЧЧ-мм-сс.тдс-[К]-[РК].png

    - .тдс - тысячные доли секунды,
    - [К]  - список отображаемых в момент сохранения каналов сверху вниз,
    - [РК] - разрешение каналов (время между вертикальными линиями или точками)
</code></pre>
<p>Имена <code>.log</code>-файлов примерно такие же. Внутри файла записываются
усреднённые по последним <code>avg_by</code> замерам данные строками в форамте:</p>
<pre><code>время в секундах &lt;TAB&gt; значение 1-го канала &lt;TAB&gt; значение 2-го канала
</code></pre>
<h2 id="_4">Прочее</h2>
<p>Настройки редактируются в текстовом редакторе, например <strong>Notepad++</strong>.
По двойному клику на <code>config.py</code> открывается обычный блокнот с самим файлом.</p>
<p>После изменения настроек программу нужно перезапустить.</p>
<p>Можно запускать несколько экземпляров программы.</p>
<p>Скрипт <code>res/pylab_plot.py</code> помогает строить графики
по данным из <code>.log</code>-файла. В программе назначены несколько клавиш, запускающих скрипт
с разными параметрами:</p>
<pre><code>P           - график канала 1
Shift+P     - график канала 2
N           - график каналов 1 и 2, приведённых к единице

X           - канал 1 как Y, канал 2 как X
Shift+X     - канал 2 как Y, канал 1 как X

H           - гистограмма распределения канала 1
Shift+H     - гистограмма распределения канала 2

L           - график регрессии канала 1 от канала 2
Shift+L     - график регрессии канала 2 от канала 1

C           - канал 1 и канал 1 как регрессия от канала 2
Shift+C     - канал 2 и канал 2 как регрессия от канала 1

D           - канал 1 минус f(канала 2)
Shift+D     - канал 2 минус f(канала 1)

J           - гистограмма канала 1 поперёк линии регрессии
Shift+J     - гистограмма канала 2 поперёк линии регрессии

F           - спектр канала 1 (ДПФ)
Shift+F     - спектр канала 2 (ДПФ)
</code></pre>
<p>Скрипт <code>pylab_plot.py</code> работает только с установленной для питона библиотекой <strong>PyLab</strong>.<br>
<em>Она же = NumPy + Matplotlib + six + dateutil + pyparsing. В общем, сложно всё, особенно
c 64-битной версией питона.</em></p>
<h1 id="_5">Теория</h1>
<p>Данные с контроллера читаются пачками по <code>N</code> значений.
Скорость получения пачек — <code>1000/N</code> в&nbsp;секунду.
Пачки складываются в буфер последовательно, так, что все полученные данные доступны одновременно.</p>
<p>График рисуется полосочками (или точками) шириной в один пиксель. Высота полосочки пропорциональна значению.
Значение для полосочки вычисляется как среднее из <code>k</code> полученных значений. Так что в один момент
в буфере содержится <code>L/k</code> данных для полосочек, где <code>L</code> - общее количество необработанных, но полученных данных.</p>
<p>Можно отрисовать все <code>L/k</code> полосочек, а можно только крайние <code>n</code>.
Если данных в буфере скопилось столько, что они точно не успеют отрисоваться, то часть из них удаляется.</p>
<p>Отрисовка происходит с периодом, указанным в настройке <code>refresh_ms</code>.</p>
<p>Настройки <code>N</code>, <code>k</code> и <code>n</code> называются <code>read_samples</code>, <code>draw_by</code> и <code>latest_n</code> соответственно. И, как бы, предназначены
для изменения количества и качества отрисовываемых данных в широких пределах.</p>
<p><em>Например, можно каждую минуту читать по 100 значений мгновенно и отображать их одной точкой,
а можно в течение минуты периодически 100 раз прочитать значения и также отобразить их одной точкой.</em></p>
<hr />
</body></html>